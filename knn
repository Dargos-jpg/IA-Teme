# ============================================================================
# STUDIU DE CAZ COMPARATIV - ALGORITMUL k-NEAREST NEIGHBORS (kNN)
# Tema 3: CƒÉutarea eficientƒÉ a vecinilor apropia»õi
# Dataset: Cost of Living Index 2024
# ============================================================================

# ----------------------------------------------------------------------------
# PASUL 1: INSTALARE »òI IMPORT BIBLIOTECI
# ----------------------------------------------------------------------------
# DacƒÉ rulezi local »ôi nu ai bibliotecile, decomenteazƒÉ linia de jos:
# !pip install pandas numpy scikit-learn matplotlib seaborn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import time
import warnings
warnings.filterwarnings('ignore')

# SetƒÉri pentru grafice
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")
plt.rcParams['figure.dpi'] = 100
plt.rcParams['savefig.dpi'] = 300

print("="*70)
print("‚úÖ Toate bibliotecile au fost importate cu succes!")
print("="*70)

# ----------------------------------------------------------------------------
# PASUL 2: √éNCƒÇRCAREA DATASETULUI
# ----------------------------------------------------------------------------
# PENTRU GOOGLE COLAB: √éncarcƒÉ fi»ôierul folosind butonul de upload din st√¢nga
# sau ruleazƒÉ: from google.colab import files; uploaded = files.upload()

# √éncarcƒÉ datasetul - SCHIMBƒÇ numele fi»ôierului dacƒÉ e diferit!
try:
    df = pd.read_csv('Cost_of_Living_Index_by_Country_2024.csv')
    print("\n‚úÖ Dataset √ÆncƒÉrcat cu succes!")
except FileNotFoundError:
    print("\n‚ùå EROARE: Fi»ôierul nu a fost gƒÉsit!")
    print("üìÅ AsigurƒÉ-te cƒÉ ai √ÆncƒÉrcat 'Cost_of_Living_Index_2024.csv'")
    print("üí° √én Google Colab: click pe üìÅ din st√¢nga »ôi upload fi»ôierul")
    raise

# Afi»ôeazƒÉ informa»õii despre dataset
print(f"\n{'='*70}")
print("üìä INFORMA»öII DESPRE DATASET")
print(f"{'='*70}")
print(f"üìà Dimensiune: {df.shape[0]} »õƒÉri, {df.shape[1]} coloane")
print(f"\nüìã Primele 3 »õƒÉri:")
print(df.head(3))
print(f"\nüìã Coloane disponibile:")
for i, col in enumerate(df.columns, 1):
    print(f"   {i}. {col}")

# ----------------------------------------------------------------------------
# PASUL 3: PREGƒÇTIREA DATELOR
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üîß PREGƒÇTIREA DATELOR")
print(f"{'='*70}")

# Coloanele numerice exacte din dataset-ul tƒÉu
feature_columns = [
    'Cost of Living Index',
    'Rent Index',
    'Cost of Living Plus Rent Index',
    'Groceries Index',
    'Restaurant Price Index',
    'Local Purchasing Power Index'
]

# VerificƒÉ dacƒÉ toate coloanele existƒÉ
missing_cols = [col for col in feature_columns if col not in df.columns]
if missing_cols:
    print(f"‚ö†Ô∏è  ATEN»öIE: Coloanele {missing_cols} lipsesc!")
    print("üí° VerificƒÉ numele exact din CSV »ôi actualizeazƒÉ lista feature_columns")

# SelecteazƒÉ doar coloanele numerice »ôi eliminƒÉ r√¢ndurile cu valori lipsƒÉ
df_clean = df[['Country'] + feature_columns].copy()
df_clean = df_clean.dropna()

print(f"‚úÖ Date curate: {df_clean.shape[0]} »õƒÉri (dupƒÉ eliminarea valorilor lipsƒÉ)")

# CreeazƒÉ categorii pentru clasificare bazate pe Cost of Living Index
# Categorii: Ieftin (0-33%), Moderat (33-66%), Scump (66-100%)
df_clean['Category'] = pd.qcut(
    df_clean['Cost of Living Index'], 
    q=3, 
    labels=['Ieftin', 'Moderat', 'Scump']
)

print(f"\nüìä Distribu»õia categoriilor de »õƒÉri:")
category_counts = df_clean['Category'].value_counts().sort_index()
for category, count in category_counts.items():
    percentage = (count / len(df_clean)) * 100
    print(f"   {category}: {count} »õƒÉri ({percentage:.1f}%)")

# Exemple de »õƒÉri din fiecare categorie
print(f"\nüåç Exemple de »õƒÉri din fiecare categorie:")
for category in ['Ieftin', 'Moderat', 'Scump']:
    countries = df_clean[df_clean['Category'] == category]['Country'].head(3).tolist()
    print(f"   {category}: {', '.join(countries)}")

# SeparƒÉ features (X) »ôi target (y)
X = df_clean[feature_columns].values
y = df_clean['Category'].values

print(f"\n‚úÖ Date pregƒÉtite: X shape = {X.shape}, y shape = {y.shape}")

# ----------------------------------------------------------------------------
# PASUL 4: NORMALIZAREA DATELOR
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("‚öñÔ∏è  NORMALIZAREA DATELOR")
print(f"{'='*70}")

# √émparte √Æn train (80%) »ôi test (20%)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print(f"üéØ Training set: {X_train.shape[0]} »õƒÉri ({(X_train.shape[0]/len(X))*100:.0f}%)")
print(f"üéØ Test set: {X_test.shape[0]} »õƒÉri ({(X_test.shape[0]/len(X))*100:.0f}%)")

# Normalizare StandardScaler: (X - Œº) / œÉ
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print(f"\n‚úÖ Datele au fost normalizate (StandardScaler)")
print(f"\nüìê Exemplu normalizare - prima »õarƒÉ:")
print(f"   √énainte: {X_train[0][:3]}")
print(f"   DupƒÉ:    {X_train_scaled[0][:3]}")
print(f"   (Medie ‚âà 0, Devia»õie standard ‚âà 1)")

# ----------------------------------------------------------------------------
# PASUL 5: EXPERIMENTUL 1 - COMPARA»öIE METODE »òI VALORI k
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üß™ EXPERIMENTUL 1: COMPARA»öIE METODE PENTRU DIFERITE VALORI ALE k")
print(f"{'='*70}")

# Parametri experimentali
k_values = [3, 5, 7, 10, 15, 20]
methods = ['brute', 'kd_tree', 'ball_tree']
method_names = ['Brute Force', 'KD-Tree', 'Ball Tree']

# Dic»õionar pentru stocarea rezultatelor
results = {
    'k': [],
    'method': [],
    'method_name': [],
    'time_ms': [],
    'accuracy': []
}

print(f"\nüöÄ TestƒÉm {len(k_values)} valori ale k √ó {len(methods)} metode = {len(k_values)*len(methods)} experimente\n")

# RuleazƒÉ toate combina»õiile
for k in k_values:
    print(f"üìç k = {k}")
    for method, name in zip(methods, method_names):
        # CreeazƒÉ modelul kNN
        knn = KNeighborsClassifier(n_neighbors=k, algorithm=method, n_jobs=-1)
        
        # MƒÉsoarƒÉ timpul de antrenare + predic»õie
        start_time = time.time()
        knn.fit(X_train_scaled, y_train)
        predictions = knn.predict(X_test_scaled)
        end_time = time.time()
        
        # CalculeazƒÉ metrici
        acc = accuracy_score(y_test, predictions)
        elapsed_ms = (end_time - start_time) * 1000  # converte»ôte √Æn milisecunde
        
        # StocheazƒÉ rezultatele
        results['k'].append(k)
        results['method'].append(method)
        results['method_name'].append(name)
        results['time_ms'].append(elapsed_ms)
        results['accuracy'].append(acc)
        
        print(f"   {name:15s} ‚Üí Timp: {elapsed_ms:7.2f} ms | Acurate»õe: {acc*100:5.1f}%")
    print()

# Converte»ôte √Æn DataFrame
results_df = pd.DataFrame(results)

print("‚úÖ Experimentul 1 completat cu succes!")

# ----------------------------------------------------------------------------
# PASUL 6: GRAFICUL 1 - TIMPUL DE EXECU»öIE VS k
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üìä GENERARE FIGURA 1: Timpul de execu»õie vs k")
print(f"{'='*70}")

plt.figure(figsize=(12, 7))

colors = ['#FF6B6B', '#4ECDC4', '#45B7D1']
markers = ['o', 's', 'D']

for i, method in enumerate(method_names):
    data = results_df[results_df['method_name'] == method]
    plt.plot(data['k'], data['time_ms'], 
             marker=markers[i], 
             linewidth=2.5, 
             markersize=10,
             label=method,
             color=colors[i])

plt.xlabel('NumƒÉrul de vecini (k)', fontsize=14, fontweight='bold')
plt.ylabel('Timp de execu»õie (ms)', fontsize=14, fontweight='bold')
plt.title('Figura 1: Compara»õia timpului de execu»õie pentru diferite valori ale k\n' + 
          f'(Dataset: {len(X_train_scaled)} »õƒÉri √Æn training, {X.shape[1]} features)',
          fontsize=15, fontweight='bold', pad=20)
plt.legend(fontsize=12, frameon=True, shadow=True, loc='best')
plt.grid(True, alpha=0.3, linestyle='--')
plt.tight_layout()
plt.savefig('figura1_timp_vs_k.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Figura 1 salvatƒÉ: 'figura1_timp_vs_k.png'")

# ----------------------------------------------------------------------------
# PASUL 7: GRAFICUL 2 - ACURATE»öEA VS k
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üìä GENERARE FIGURA 2: Acurate»õea vs k")
print(f"{'='*70}")

plt.figure(figsize=(12, 7))

for i, method in enumerate(method_names):
    data = results_df[results_df['method_name'] == method]
    plt.plot(data['k'], data['accuracy']*100, 
             marker=markers[i], 
             linewidth=2.5, 
             markersize=10,
             label=method,
             color=colors[i])

plt.xlabel('NumƒÉrul de vecini (k)', fontsize=14, fontweight='bold')
plt.ylabel('Acurate»õe (%)', fontsize=14, fontweight='bold')
plt.title('Figura 2: Compara»õia acurate»õei pentru diferite valori ale k\n' +
          f'(Test set: {len(X_test_scaled)} »õƒÉri)',
          fontsize=15, fontweight='bold', pad=20)
plt.legend(fontsize=12, frameon=True, shadow=True, loc='best')
plt.grid(True, alpha=0.3, linestyle='--')
plt.ylim([0, 105])
plt.tight_layout()
plt.savefig('figura2_acuratete_vs_k.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Figura 2 salvatƒÉ: 'figura2_acuratete_vs_k.png'")

# ----------------------------------------------------------------------------
# PASUL 8: EXPERIMENTUL 2 - SCALABILITATE
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üß™ EXPERIMENTUL 2: SCALABILITATE √éN FUNC»öIE DE MƒÇRIMEA DATASETULUI")
print(f"{'='*70}")

# Dimensiuni diferite pentru testare
n_total = len(X_train_scaled)
if n_total >= 100:
    n_values = [int(n_total*0.3), int(n_total*0.6), n_total]
else:
    n_values = [max(30, int(n_total*0.5)), n_total]

k_fixed = 5  # k fix pentru acest experiment

scalability_results = {
    'n': [],
    'method': [],
    'method_name': [],
    'time_ms': [],
}

print(f"üî¨ TestƒÉm cu k={k_fixed} fix, pentru n = {n_values}\n")

for n in n_values:
    print(f"üìç n = {n} »õƒÉri")
    # Ia primele n exemple
    X_subset = X_train_scaled[:n]
    y_subset = y_train[:n]
    
    for method, name in zip(methods, method_names):
        knn = KNeighborsClassifier(n_neighbors=k_fixed, algorithm=method, n_jobs=-1)
        
        start_time = time.time()
        knn.fit(X_subset, y_subset)
        predictions = knn.predict(X_test_scaled)
        end_time = time.time()
        
        elapsed_ms = (end_time - start_time) * 1000
        
        scalability_results['n'].append(n)
        scalability_results['method'].append(method)
        scalability_results['method_name'].append(name)
        scalability_results['time_ms'].append(elapsed_ms)
        
        print(f"   {name:15s} ‚Üí Timp: {elapsed_ms:7.2f} ms")
    print()

scalability_df = pd.DataFrame(scalability_results)
print("‚úÖ Experimentul 2 completat cu succes!")

# ----------------------------------------------------------------------------
# PASUL 9: GRAFICUL 3 - SCALABILITATE
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üìä GENERARE FIGURA 3: Scalabilitatea metodelor")
print(f"{'='*70}")

plt.figure(figsize=(12, 7))

for i, method in enumerate(method_names):
    data = scalability_df[scalability_df['method_name'] == method]
    plt.plot(data['n'], data['time_ms'], 
             marker=markers[i], 
             linewidth=3, 
             markersize=12,
             label=method,
             color=colors[i])

plt.xlabel('NumƒÉrul de »õƒÉri √Æn training set (n)', fontsize=14, fontweight='bold')
plt.ylabel('Timp de execu»õie (ms)', fontsize=14, fontweight='bold')
plt.title(f'Figura 3: Scalabilitatea metodelor √Æn func»õie de dimensiunea datasetului\n(k={k_fixed}, {X.shape[1]} features)',
          fontsize=15, fontweight='bold', pad=20)
plt.legend(fontsize=12, frameon=True, shadow=True, loc='best')
plt.grid(True, alpha=0.3, linestyle='--')
plt.tight_layout()
plt.savefig('figura3_scalabilitate.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Figura 3 salvatƒÉ: 'figura3_scalabilitate.png'")

# ----------------------------------------------------------------------------
# PASUL 10: TABELUL CU REZULTATE
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üìã GENERARE TABEL: Compara»õie performan»õƒÉ metode")
print(f"{'='*70}")

# Tabel sumar pentru k=5
k_target = 5
summary = results_df[results_df['k'] == k_target][['method_name', 'time_ms', 'accuracy']].copy()

# CalculeazƒÉ speedup fa»õƒÉ de Brute Force
brute_time = summary[summary['method_name'] == 'Brute Force']['time_ms'].values[0]
summary['speedup'] = brute_time / summary['time_ms']

print(f"\n{'='*80}")
print(f"TABELUL 1: Performan»õa metodelor de cƒÉutare a vecinilor")
print(f"(k={k_target}, n={len(X_train_scaled)} »õƒÉri, d={X.shape[1]} features)")
print(f"{'='*80}")
print(f"{'MetodƒÉ':<20} {'Timp (ms)':<15} {'Acurate»õe (%)':<18} {'Speedup':<12}")
print(f"{'-'*80}")

for _, row in summary.iterrows():
    print(f"{row['method_name']:<20} {row['time_ms']:<15.2f} {row['accuracy']*100:<18.1f} {row['speedup']:<12.2f}x")

print(f"{'='*80}")

# SalveazƒÉ √Æn CSV pentru Word
summary.to_csv('tabel1_rezultate.csv', index=False)
print("\n‚úÖ Tabelul salvat: 'tabel1_rezultate.csv'")

# Tabel suplimentar: Timpul mediu pe metodƒÉ
print(f"\n{'='*80}")
print("TABELUL 2: Timpul mediu de execu»õie pe toate valorile k testate")
print(f"{'='*80}")

avg_times = results_df.groupby('method_name')['time_ms'].agg(['mean', 'std', 'min', 'max'])
print(avg_times.to_string())
print(f"{'='*80}")

# ----------------------------------------------------------------------------
# PASUL 11: GRAFIC COMBINAT (BONUS)
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üìä GENERARE FIGURA 4: AnalizƒÉ comparativƒÉ completƒÉ (4 subgrafice)")
print(f"{'='*70}")

fig, axes = plt.subplots(2, 2, figsize=(16, 12))
fig.suptitle('Figura 4: Analiza comparativƒÉ completƒÉ a metodelor kNN\n' +
             f'Dataset: Cost of Living Index 2024 ({len(X)} »õƒÉri, {X.shape[1]} features)', 
             fontsize=17, fontweight='bold', y=0.995)

# Subplot 1: Timp vs k
ax1 = axes[0, 0]
for i, method in enumerate(method_names):
    data = results_df[results_df['method_name'] == method]
    ax1.plot(data['k'], data['time_ms'], marker=markers[i], linewidth=2.5, 
             markersize=9, label=method, color=colors[i])
ax1.set_xlabel('k (numƒÉr vecini)', fontsize=12, fontweight='bold')
ax1.set_ylabel('Timp (ms)', fontsize=12, fontweight='bold')
ax1.set_title('a) Timpul de execu»õie √Æn func»õie de k', fontsize=13, fontweight='bold', pad=10)
ax1.legend(fontsize=10, frameon=True)
ax1.grid(True, alpha=0.3, linestyle='--')

# Subplot 2: Acurate»õe vs k
ax2 = axes[0, 1]
for i, method in enumerate(method_names):
    data = results_df[results_df['method_name'] == method]
    ax2.plot(data['k'], data['accuracy']*100, marker=markers[i], linewidth=2.5,
             markersize=9, label=method, color=colors[i])
ax2.set_xlabel('k (numƒÉr vecini)', fontsize=12, fontweight='bold')
ax2.set_ylabel('Acurate»õe (%)', fontsize=12, fontweight='bold')
ax2.set_title('b) Acurate»õea √Æn func»õie de k', fontsize=13, fontweight='bold', pad=10)
ax2.legend(fontsize=10, frameon=True)
ax2.grid(True, alpha=0.3, linestyle='--')
ax2.set_ylim([0, 105])

# Subplot 3: Scalabilitate
ax3 = axes[1, 0]
for i, method in enumerate(method_names):
    data = scalability_df[scalability_df['method_name'] == method]
    ax3.plot(data['n'], data['time_ms'], marker=markers[i], linewidth=2.5,
             markersize=9, label=method, color=colors[i])
ax3.set_xlabel('n (mƒÉrime training set)', fontsize=12, fontweight='bold')
ax3.set_ylabel('Timp (ms)', fontsize=12, fontweight='bold')
ax3.set_title(f'c) Scalabilitatea metodelor (k={k_fixed})', fontsize=13, fontweight='bold', pad=10)
ax3.legend(fontsize=10, frameon=True)
ax3.grid(True, alpha=0.3, linestyle='--')

# Subplot 4: Bar chart compara»õie directƒÉ
ax4 = axes[1, 1]
k5_data = results_df[results_df['k'] == 5]
x_pos = np.arange(len(method_names))
times = k5_data['time_ms'].values
bars = ax4.bar(x_pos, times, color=colors, edgecolor='black', linewidth=1.5)
ax4.set_xlabel('MetodƒÉ', fontsize=12, fontweight='bold')
ax4.set_ylabel('Timp (ms)', fontsize=12, fontweight='bold')
ax4.set_title(f'd) Compara»õie directƒÉ (k=5)', fontsize=13, fontweight='bold', pad=10)
ax4.set_xticks(x_pos)
ax4.set_xticklabels(method_names, rotation=0)
ax4.grid(True, alpha=0.3, axis='y', linestyle='--')

# AdaugƒÉ valorile pe bare
for bar, time_val in zip(bars, times):
    height = bar.get_height()
    ax4.text(bar.get_x() + bar.get_width()/2., height + 0.5,
             f'{time_val:.1f} ms', ha='center', va='bottom', fontweight='bold', fontsize=10)

plt.tight_layout()
plt.savefig('figura4_analiza_completa.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Figura 4 salvatƒÉ: 'figura4_analiza_completa.png'")

# ----------------------------------------------------------------------------
# PASUL 12: ANALIZA DETALIATƒÇ PENTRU k OPTIM
# ----------------------------------------------------------------------------
print(f"\n{'='*70}")
print("üîç ANALIZA DETALIATƒÇ: Alegerea valorii optime a lui k")
print(f"{'='*70}")

# GƒÉse»ôte k optim pentru fiecare metodƒÉ
print("\nüìä k optim pentru fiecare metodƒÉ (bazat pe acurate»õe):\n")

for method in method_names:
    method_data = results_df[results_df['method_name'] == method]
    best_idx = method_data['accuracy'].idxmax()
    best_row = method_data.loc[best_idx]
    
    print(f"   {method}:")
    print(f"      ‚Üí k optim: {int(best_row['k'])}")
    print(f"      ‚Üí Acurate»õe maximƒÉ: {best_row['accuracy']*100:.2f}%")
    print(f"      ‚Üí Timp la k optim: {best_row['time_ms']:.2f} ms")
    print()

# ----------------------------------------------------------------------------
# PASUL 13: SUMAR FINAL »òI CONCLUZII
# ----------------------------------------------------------------------------
print(f"\n{'='*80}")
print("üéâ SUMAR FINAL - REZULTATE »òI CONCLUZII")
print(f"{'='*80}")

# Statistici generale
fastest_method = results_df.groupby('method_name')['time_ms'].mean().idxmin()
fastest_time = results_df.groupby('method_name')['time_ms'].mean().min()

most_accurate = results_df.groupby('method_name')['accuracy'].mean().idxmax()
best_acc = results_df.groupby('method_name')['accuracy'].mean().max()

brute_avg = results_df[results_df['method_name'] == 'Brute Force']['time_ms'].mean()
kd_avg = results_df[results_df['method_name'] == 'KD-Tree']['time_ms'].mean()
overall_speedup = brute_avg / kd_avg

print(f"\nüèÜ CEA MAI RAPIDƒÇ METODƒÇ: {fastest_method}")
print(f"   ‚Üí Timp mediu: {fastest_time:.2f} ms")
print(f"   ‚Üí Reducere de {((brute_avg - fastest_time)/brute_avg * 100):.1f}% fa»õƒÉ de Brute Force")

print(f"\nüéØ CEA MAI PRECISƒÇ METODƒÇ: {most_accurate}")
print(f"   ‚Üí Acurate»õe medie: {best_acc*100:.2f}%")

print(f"\n‚ö° SPEEDUP GENERAL:")
print(f"   ‚Üí KD-Tree vs Brute Force: {overall_speedup:.2f}x mai rapid")
print(f"   ‚Üí Economie de timp: {((overall_speedup-1)*100):.0f}%")

print(f"\nüìä INFORMA»öII DATASET:")
print(f"   ‚Üí Total »õƒÉri: {len(X)}")
print(f"   ‚Üí Features (dimensiuni): {X.shape[1]}")
print(f"   ‚Üí Training: {len(X_train_scaled)} »õƒÉri ({(len(X_train_scaled)/len(X))*100:.0f}%)")
print(f"   ‚Üí Test: {len(X_test_scaled)} »õƒÉri ({(len(X_test_scaled)/len(X))*100:.0f}%)")
print(f"   ‚Üí Categorii: {len(np.unique(y))} (Ieftin, Moderat, Scump)")

print(f"\nüìÅ FI»òIERE GENERATE:")
print("   1. ‚úÖ figura1_timp_vs_k.png")
print("   2. ‚úÖ figura2_acuratete_vs_k.png")
print("   3. ‚úÖ figura3_scalabilitate.png")
print("   4. ‚úÖ figura4_analiza_completa.png")
print("   5. ‚úÖ tabel1_rezultate.csv")

print(f"\nüí° CONCLUZII CHEIE:")
print(f"   1. KD-Tree reduce timpul cu ~{((overall_speedup-1)*100):.0f}% fa»õƒÉ de Brute Force")
print(f"   2. Toate metodele oferƒÉ acurate»õe similarƒÉ (~{best_acc*100:.0f}%)")
print(f"   3. Pentru d={X.shape[1]} dimensiuni, KD-Tree este optim")
print(f"   4. Complexitatea O(n¬∑d) a Brute Force devine problematicƒÉ la scale")

print(f"\nüìù NEXT STEPS PENTRU LUCRAREA TA:")
print("   ‚úì CopiazƒÉ toate graficele √Æn Word")
print("   ‚úì InsereazƒÉ datele din tabel1_rezultate.csv")
print("   ‚úì ExplicƒÉ rezultatele folosind valorile numerice de mai sus")
print("   ‚úì Men»õioneazƒÉ complexitatea O(n¬∑d) pentru Brute Force")
print("   ‚úì DiscutƒÉ trade-off-ul timp construc»õie vs timp query")

print(f"\n{'='*80}")
print("üéì Cod executat cu succes! Succes la proiect!")
print(f"{'='*80}")
